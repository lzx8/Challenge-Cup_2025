{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _traverse = require(\"@babel/traverse\");\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)(({\n  types: t,\n  assertVersion\n}) => {\n  assertVersion(7);\n  const containsClassExpressionVisitor = {\n    ClassExpression(path, state) {\n      state.found = true;\n      path.stop();\n    },\n    Function(path) {\n      path.skip();\n    }\n  };\n  const containsYieldOrAwaitVisitor = _traverse.visitors.environmentVisitor({\n    YieldExpression(path, state) {\n      state.yield = true;\n      if (state.await) path.stop();\n    },\n    AwaitExpression(path, state) {\n      state.await = true;\n      if (state.yield) path.stop();\n    }\n  });\n  function containsClassExpression(path) {\n    if (t.isClassExpression(path.node)) return true;\n    if (t.isFunction(path.node)) return false;\n    const state = {\n      found: false\n    };\n    path.traverse(containsClassExpressionVisitor, state);\n    return state.found;\n  }\n  function wrap(path) {\n    const context = {\n      yield: t.isYieldExpression(path.node),\n      await: t.isAwaitExpression(path.node)\n    };\n    path.traverse(containsYieldOrAwaitVisitor, context);\n    let replacement;\n    if (context.yield) {\n      const fn = t.functionExpression(null, [], t.blockStatement([t.returnStatement(path.node)]), true, context.await);\n      replacement = t.yieldExpression(t.callExpression(t.memberExpression(fn, t.identifier(\"call\")), [t.thisExpression(), t.identifier(\"arguments\")]), true);\n    } else {\n      const fn = t.arrowFunctionExpression([], path.node, context.await);\n      replacement = t.callExpression(fn, []);\n      if (context.await) replacement = t.awaitExpression(replacement);\n    }\n    path.replaceWith(replacement);\n  }\n  return {\n    name: \"bugfix-firefox-class-in-computed-class-key\",\n    visitor: {\n      Class(path) {\n        const hasPrivateElement = path.node.body.body.some(node => t.isPrivate(node));\n        if (!hasPrivateElement) return;\n        for (const elem of path.get(\"body.body\")) {\n          if (\"computed\" in elem.node && elem.node.computed && containsClassExpression(elem.get(\"key\"))) {\n            wrap(elem.get(\"key\"));\n          }\n        }\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n"]}