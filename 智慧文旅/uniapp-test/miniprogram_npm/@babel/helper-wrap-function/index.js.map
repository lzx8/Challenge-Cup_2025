{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = wrapFunction;\nvar _template = require(\"@babel/template\");\nvar _t = require(\"@babel/types\");\nconst {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression,\n  memberExpression,\n  identifier,\n  thisExpression,\n  isPattern\n} = _t;\nconst buildAnonymousExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`);\nconst buildNamedExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`);\nconst buildDeclarationWrapper = _template.default.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\nfunction classOrObjectMethod(path, callId, ignoreFunctionLength) {\n  const node = path.node;\n  const body = node.body;\n  let params = [];\n  const shoudlForwardParams = node.params.some(p => isPattern(p));\n  if (shoudlForwardParams) {\n    params = node.params;\n    node.params = [];\n    if (!ignoreFunctionLength) {\n      for (const param of params) {\n        if (isAssignmentPattern(param) || isRestElement(param)) {\n          break;\n        }\n        node.params.push(path.scope.generateUidIdentifier(\"x\"));\n      }\n    }\n  }\n  const container = functionExpression(null, params, blockStatement(body.body), true);\n  if (shoudlForwardParams) {\n    body.body = [returnStatement(callExpression(memberExpression(callExpression(callId, [container]), identifier(\"apply\")), [thisExpression(), identifier(\"arguments\")]))];\n    path.get(\"body.body.0.argument.callee.object.arguments.0\").unwrapFunctionEnvironment();\n  } else {\n    body.body = [returnStatement(callExpression(callExpression(callId, [container]), []))];\n    path.get(\"body.body.0.argument.callee.arguments.0\").unwrapFunctionEnvironment();\n  }\n  node.async = false;\n  node.generator = false;\n}\nfunction plainFunction(inPath, callId, noNewArrows, ignoreFunctionLength, hadName) {\n  let path = inPath;\n  let node;\n  let functionId = null;\n  const nodeParams = inPath.node.params;\n  if (path.isArrowFunctionExpression()) {\n    {\n      var _path$arrowFunctionTo;\n      path = (_path$arrowFunctionTo = path.arrowFunctionToExpression({\n        noNewArrows\n      })) != null ? _path$arrowFunctionTo : path;\n    }\n    node = path.node;\n  } else {\n    node = path.node;\n  }\n  const isDeclaration = isFunctionDeclaration(node);\n  let built = node;\n  if (!isCallExpression(node)) {\n    functionId = node.id;\n    node.id = null;\n    node.type = \"FunctionExpression\";\n    built = callExpression(callId, [node]);\n  }\n  const params = [];\n  for (const param of nodeParams) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n  const wrapperArgs = {\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(hadName ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params\n  };\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n    if (hadName) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n    }\n    if (functionId || !ignoreFunctionLength && params.length) {\n      path.replaceWith(container);\n    } else {\n      path.replaceWith(built);\n    }\n  }\n}\nfunction wrapFunction(path, callId, noNewArrows = true, ignoreFunctionLength = false) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId, ignoreFunctionLength);\n  } else {\n    const hadName = \"id\" in path.node && !!path.node.id;\n    {\n      var _path, _path$ensureFunctionN;\n      (_path$ensureFunctionN = (_path = path).ensureFunctionName) != null ? _path$ensureFunctionN : _path.ensureFunctionName = require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n    }\n    path = path.ensureFunctionName(false);\n    plainFunction(path, callId, noNewArrows, ignoreFunctionLength, hadName);\n  }\n}\n\n//# sourceMappingURL=index.js.map\n"]}