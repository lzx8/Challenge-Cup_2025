{"version":3,"sources":["index.js","import-injector.js","import-builder.js","is-module.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ImportInjector\", {\n  enumerable: true,\n  get: function () {\n    return _importInjector.default;\n  }\n});\nexports.addDefault = addDefault;\nexports.addNamed = addNamed;\nexports.addNamespace = addNamespace;\nexports.addSideEffect = addSideEffect;\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _isModule.default;\n  }\n});\nvar _importInjector = require(\"./import-injector.js\");\nvar _isModule = require(\"./is-module.js\");\nfunction addDefault(path, importedSource, opts) {\n  return new _importInjector.default(path).addDefault(importedSource, opts);\n}\nfunction addNamed(path, name, importedSource, opts) {\n  return new _importInjector.default(path).addNamed(name, importedSource, opts);\n}\nfunction addNamespace(path, importedSource, opts) {\n  return new _importInjector.default(path).addNamespace(importedSource, opts);\n}\nfunction addSideEffect(path, importedSource, opts) {\n  return new _importInjector.default(path).addSideEffect(importedSource, opts);\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _assert = require(\"assert\");\nvar _t = require(\"@babel/types\");\nvar _importBuilder = require(\"./import-builder.js\");\nvar _isModule = require(\"./is-module.js\");\nconst {\n  identifier,\n  importSpecifier,\n  numericLiteral,\n  sequenceExpression,\n  isImportDeclaration\n} = _t;\nclass ImportInjector {\n  constructor(path, importedSource, opts) {\n    this._defaultOpts = {\n      importedSource: null,\n      importedType: \"commonjs\",\n      importedInterop: \"babel\",\n      importingInterop: \"babel\",\n      ensureLiveReference: false,\n      ensureNoContext: false,\n      importPosition: \"before\"\n    };\n    const programPath = path.find(p => p.isProgram());\n    this._programPath = programPath;\n    this._programScope = programPath.scope;\n    this._hub = programPath.hub;\n    this._defaultOpts = this._applyDefaults(importedSource, opts, true);\n  }\n  addDefault(importedSourceIn, opts) {\n    return this.addNamed(\"default\", importedSourceIn, opts);\n  }\n  addNamed(importName, importedSourceIn, opts) {\n    _assert(typeof importName === \"string\");\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);\n  }\n  addNamespace(importedSourceIn, opts) {\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);\n  }\n  addSideEffect(importedSourceIn, opts) {\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);\n  }\n  _applyDefaults(importedSource, opts, isInit = false) {\n    let newOpts;\n    if (typeof importedSource === \"string\") {\n      newOpts = Object.assign({}, this._defaultOpts, {\n        importedSource\n      }, opts);\n    } else {\n      _assert(!opts, \"Unexpected secondary arguments.\");\n      newOpts = Object.assign({}, this._defaultOpts, importedSource);\n    }\n    if (!isInit && opts) {\n      if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;\n      if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;\n    }\n    return newOpts;\n  }\n  _generateImport(opts, importName) {\n    const isDefault = importName === \"default\";\n    const isNamed = !!importName && !isDefault;\n    const isNamespace = importName === null;\n    const {\n      importedSource,\n      importedType,\n      importedInterop,\n      importingInterop,\n      ensureLiveReference,\n      ensureNoContext,\n      nameHint,\n      importPosition,\n      blockHoist\n    } = opts;\n    let name = nameHint || importName;\n    const isMod = (0, _isModule.default)(this._programPath);\n    const isModuleForNode = isMod && importingInterop === \"node\";\n    const isModuleForBabel = isMod && importingInterop === \"babel\";\n    if (importPosition === \"after\" && !isMod) {\n      throw new Error(`\"importPosition\": \"after\" is only supported in modules`);\n    }\n    const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);\n    if (importedType === \"es6\") {\n      if (!isModuleForNode && !isModuleForBabel) {\n        throw new Error(\"Cannot import an ES6 module from CommonJS\");\n      }\n      builder.import();\n      if (isNamespace) {\n        builder.namespace(nameHint || importedSource);\n      } else if (isDefault || isNamed) {\n        builder.named(name, importName);\n      }\n    } else if (importedType !== \"commonjs\") {\n      throw new Error(`Unexpected interopType \"${importedType}\"`);\n    } else if (importedInterop === \"babel\") {\n      if (isModuleForNode) {\n        name = name !== \"default\" ? name : importedSource;\n        const es6Default = `${importedSource}$es6Default`;\n        builder.import();\n        if (isNamespace) {\n          builder.default(es6Default).var(name || importedSource).wildcardInterop();\n        } else if (isDefault) {\n          if (ensureLiveReference) {\n            builder.default(es6Default).var(name || importedSource).defaultInterop().read(\"default\");\n          } else {\n            builder.default(es6Default).var(name).defaultInterop().prop(importName);\n          }\n        } else if (isNamed) {\n          builder.default(es6Default).read(importName);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource).wildcardInterop();\n        } else if ((isDefault || isNamed) && ensureLiveReference) {\n          if (isDefault) {\n            name = name !== \"default\" ? name : importedSource;\n            builder.var(name).read(importName);\n            builder.defaultInterop();\n          } else {\n            builder.var(importedSource).read(importName);\n          }\n        } else if (isDefault) {\n          builder.var(name).defaultInterop().prop(importName);\n        } else if (isNamed) {\n          builder.var(name).prop(importName);\n        }\n      }\n    } else if (importedInterop === \"compiled\") {\n      if (isModuleForNode) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault || isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.prop(importName).var(name);\n          }\n        }\n      }\n    } else if (importedInterop === \"uncompiled\") {\n      if (isDefault && ensureLiveReference) {\n        throw new Error(\"No live reference for commonjs default\");\n      }\n      if (isModuleForNode) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault) {\n          builder.var(name);\n        } else if (isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.var(name).prop(importName);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Unknown importedInterop \"${importedInterop}\".`);\n    }\n    const {\n      statements,\n      resultName\n    } = builder.done();\n    this._insertStatements(statements, importPosition, blockHoist);\n    if ((isDefault || isNamed) && ensureNoContext && resultName.type !== \"Identifier\") {\n      return sequenceExpression([numericLiteral(0), resultName]);\n    }\n    return resultName;\n  }\n  _insertStatements(statements, importPosition = \"before\", blockHoist = 3) {\n    if (importPosition === \"after\") {\n      if (this._insertStatementsAfter(statements)) return;\n    } else {\n      if (this._insertStatementsBefore(statements, blockHoist)) return;\n    }\n    this._programPath.unshiftContainer(\"body\", statements);\n  }\n  _insertStatementsBefore(statements, blockHoist) {\n    if (statements.length === 1 && isImportDeclaration(statements[0]) && isValueImport(statements[0])) {\n      const firstImportDecl = this._programPath.get(\"body\").find(p => {\n        return p.isImportDeclaration() && isValueImport(p.node);\n      });\n      if ((firstImportDecl == null ? void 0 : firstImportDecl.node.source.value) === statements[0].source.value && maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])) {\n        return true;\n      }\n    }\n    statements.forEach(node => {\n      node._blockHoist = blockHoist;\n    });\n    const targetPath = this._programPath.get(\"body\").find(p => {\n      const val = p.node._blockHoist;\n      return Number.isFinite(val) && val < 4;\n    });\n    if (targetPath) {\n      targetPath.insertBefore(statements);\n      return true;\n    }\n    return false;\n  }\n  _insertStatementsAfter(statements) {\n    const statementsSet = new Set(statements);\n    const importDeclarations = new Map();\n    for (const statement of statements) {\n      if (isImportDeclaration(statement) && isValueImport(statement)) {\n        const source = statement.source.value;\n        if (!importDeclarations.has(source)) importDeclarations.set(source, []);\n        importDeclarations.get(source).push(statement);\n      }\n    }\n    let lastImportPath = null;\n    for (const bodyStmt of this._programPath.get(\"body\")) {\n      if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {\n        lastImportPath = bodyStmt;\n        const source = bodyStmt.node.source.value;\n        const newImports = importDeclarations.get(source);\n        if (!newImports) continue;\n        for (const decl of newImports) {\n          if (!statementsSet.has(decl)) continue;\n          if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {\n            statementsSet.delete(decl);\n          }\n        }\n      }\n    }\n    if (statementsSet.size === 0) return true;\n    if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));\n    return !!lastImportPath;\n  }\n}\nexports.default = ImportInjector;\nfunction isValueImport(node) {\n  return node.importKind !== \"type\" && node.importKind !== \"typeof\";\n}\nfunction hasNamespaceImport(node) {\n  return node.specifiers.length === 1 && node.specifiers[0].type === \"ImportNamespaceSpecifier\" || node.specifiers.length === 2 && node.specifiers[1].type === \"ImportNamespaceSpecifier\";\n}\nfunction hasDefaultImport(node) {\n  return node.specifiers.length > 0 && node.specifiers[0].type === \"ImportDefaultSpecifier\";\n}\nfunction maybeAppendImportSpecifiers(target, source) {\n  if (!target.specifiers.length) {\n    target.specifiers = source.specifiers;\n    return true;\n  }\n  if (!source.specifiers.length) return true;\n  if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;\n  if (hasDefaultImport(source)) {\n    if (hasDefaultImport(target)) {\n      source.specifiers[0] = importSpecifier(source.specifiers[0].local, identifier(\"default\"));\n    } else {\n      target.specifiers.unshift(source.specifiers.shift());\n    }\n  }\n  target.specifiers.push(...source.specifiers);\n  return true;\n}\n\n//# sourceMappingURL=import-injector.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _assert = require(\"assert\");\nvar _t = require(\"@babel/types\");\nconst {\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  importDeclaration,\n  importDefaultSpecifier,\n  importNamespaceSpecifier,\n  importSpecifier,\n  memberExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nclass ImportBuilder {\n  constructor(importedSource, scope, hub) {\n    this._statements = [];\n    this._resultName = null;\n    this._importedSource = void 0;\n    this._scope = scope;\n    this._hub = hub;\n    this._importedSource = importedSource;\n  }\n  done() {\n    return {\n      statements: this._statements,\n      resultName: this._resultName\n    };\n  }\n  import() {\n    this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));\n    return this;\n  }\n  require() {\n    this._statements.push(expressionStatement(callExpression(identifier(\"require\"), [stringLiteral(this._importedSource)])));\n    return this;\n  }\n  namespace(name = \"namespace\") {\n    const local = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    _assert(statement.type === \"ImportDeclaration\");\n    _assert(statement.specifiers.length === 0);\n    statement.specifiers = [importNamespaceSpecifier(local)];\n    this._resultName = cloneNode(local);\n    return this;\n  }\n  default(name) {\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    _assert(statement.type === \"ImportDeclaration\");\n    _assert(statement.specifiers.length === 0);\n    statement.specifiers = [importDefaultSpecifier(id)];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  named(name, importName) {\n    if (importName === \"default\") return this.default(name);\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    _assert(statement.type === \"ImportDeclaration\");\n    _assert(statement.specifiers.length === 0);\n    statement.specifiers = [importSpecifier(id, identifier(importName))];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  var(name) {\n    const id = this._scope.generateUidIdentifier(name);\n    let statement = this._statements[this._statements.length - 1];\n    if (statement.type !== \"ExpressionStatement\") {\n      _assert(this._resultName);\n      statement = expressionStatement(this._resultName);\n      this._statements.push(statement);\n    }\n    this._statements[this._statements.length - 1] = variableDeclaration(\"var\", [variableDeclarator(id, statement.expression)]);\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  defaultInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireDefault\"));\n  }\n  wildcardInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireWildcard\"));\n  }\n  _interop(callee) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = callExpression(callee, [statement.expression]);\n    } else if (statement.type === \"VariableDeclaration\") {\n      _assert(statement.declarations.length === 1);\n      statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init]);\n    } else {\n      _assert.fail(\"Unexpected type.\");\n    }\n    return this;\n  }\n  prop(name) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = memberExpression(statement.expression, identifier(name));\n    } else if (statement.type === \"VariableDeclaration\") {\n      _assert(statement.declarations.length === 1);\n      statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));\n    } else {\n      _assert.fail(\"Unexpected type:\" + statement.type);\n    }\n    return this;\n  }\n  read(name) {\n    this._resultName = memberExpression(this._resultName, identifier(name));\n  }\n}\nexports.default = ImportBuilder;\n\n//# sourceMappingURL=import-builder.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isModule;\nfunction isModule(path) {\n  return path.node.sourceType === \"module\";\n}\n\n//# sourceMappingURL=is-module.js.map\n"]}