{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\nvar _core = require(\"@babel/core\");\nvar _traverse = require(\"@babel/traverse\");\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression\n} = _core.types;\n{\n  exports.environmentVisitor = _traverse.visitors.environmentVisitor({});\n  exports.skipAllButComputedKey = function skipAllButComputedKey(path) {\n    path.skip();\n    if (path.node.computed) {\n      path.context.maybeQueue(path.get(\"key\"));\n    }\n  };\n}\nconst visitor = _traverse.visitors.environmentVisitor({\n  Super(path, state) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n});\nconst unshadowSuperBindingVisitor = _traverse.visitors.environmentVisitor({\n  Scopable(path, {\n    refName\n  }) {\n    const binding = path.scope.getOwnBinding(refName);\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n});\nconst specHandlers = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n    if (!computed) {\n      return;\n    }\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n    this.memoiser.set(property, memo, count);\n  },\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n    if (computed) {\n      return cloneNode(property);\n    }\n    return stringLiteral(property.name);\n  },\n  _getPrototypeOfExpression() {\n    const objectRef = cloneNode(this.getObjectRef());\n    const targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier(\"prototype\"));\n    return callExpression(this.file.addHelper(\"getPrototypeOf\"), [targetRef]);\n  },\n  get(superMember) {\n    const objectRef = cloneNode(this.getObjectRef());\n    return callExpression(this.file.addHelper(\"superPropGet\"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), thisExpression(), ...(this.isStatic || this.isPrivateMethod ? [] : [_core.types.numericLiteral(1)])]);\n  },\n  _call(superMember, args, optional) {\n    const objectRef = cloneNode(this.getObjectRef());\n    let argsNode;\n    if (args.length === 1 && _core.types.isSpreadElement(args[0]) && (_core.types.isIdentifier(args[0].argument) || _core.types.isArrayExpression(args[0].argument))) {\n      argsNode = args[0].argument;\n    } else {\n      argsNode = _core.types.arrayExpression(args);\n    }\n    const call = _core.types.callExpression(this.file.addHelper(\"superPropGet\"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), thisExpression(), _core.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);\n    if (optional) {\n      return _core.types.optionalCallExpression(call, [argsNode], true);\n    }\n    return callExpression(call, [argsNode]);\n  },\n  set(superMember, value) {\n    const objectRef = cloneNode(this.getObjectRef());\n    return callExpression(this.file.addHelper(\"superPropSet\"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), value, thisExpression(), _core.types.numericLiteral(superMember.isInStrictMode() ? 1 : 0), ...(this.isStatic || this.isPrivateMethod ? [] : [_core.types.numericLiteral(1)])]);\n  },\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n  call(superMember, args) {\n    return this._call(superMember, args, false);\n  },\n  optionalCall(superMember, args) {\n    return this._call(superMember, args, true);\n  },\n  delete(superMember) {\n    if (superMember.node.computed) {\n      return sequenceExpression([callExpression(this.file.addHelper(\"toPropertyKey\"), [cloneNode(superMember.node.property)]), _core.template.expression.ast`\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        `]);\n    } else {\n      return _core.template.expression.ast`\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      `;\n    }\n  }\n};\nconst specHandlers_old = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n    if (!computed) {\n      return;\n    }\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n    this.memoiser.set(property, memo, count);\n  },\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n    if (computed) {\n      return cloneNode(property);\n    }\n    return stringLiteral(property.name);\n  },\n  _getPrototypeOfExpression() {\n    const objectRef = cloneNode(this.getObjectRef());\n    const targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier(\"prototype\"));\n    return callExpression(this.file.addHelper(\"getPrototypeOf\"), [targetRef]);\n  },\n  get(superMember) {\n    return this._get(superMember);\n  },\n  _get(superMember) {\n    const proto = this._getPrototypeOfExpression();\n    return callExpression(this.file.addHelper(\"get\"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), proto]) : proto, this.prop(superMember), thisExpression()]);\n  },\n  set(superMember, value) {\n    const proto = this._getPrototypeOfExpression();\n    return callExpression(this.file.addHelper(\"set\"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), proto]) : proto, this.prop(superMember), value, thisExpression(), _core.types.booleanLiteral(superMember.isInStrictMode())]);\n  },\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember), thisExpression(), args, false);\n  },\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember), cloneNode(thisExpression()), args, true);\n  },\n  delete(superMember) {\n    if (superMember.node.computed) {\n      return sequenceExpression([callExpression(this.file.addHelper(\"toPropertyKey\"), [cloneNode(superMember.node.property)]), _core.template.expression.ast`\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        `]);\n    } else {\n      return _core.template.expression.ast`\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      `;\n    }\n  }\n};\nconst looseHandlers = Object.assign({}, specHandlers, {\n  prop(superMember) {\n    const {\n      property\n    } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n    return cloneNode(property);\n  },\n  get(superMember) {\n    const {\n      isStatic,\n      getSuperRef\n    } = this;\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    let object;\n    if (isStatic) {\n      var _getSuperRef;\n      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      var _getSuperRef2;\n      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier(\"Object\"), identifier(\"prototype\"));\n    }\n    return memberExpression(object, prop, computed);\n  },\n  set(superMember, value) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return assignmentExpression(\"=\", memberExpression(thisExpression(), prop, computed), value);\n  },\n  destructureSet(superMember) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return memberExpression(thisExpression(), prop, computed);\n  },\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);\n  },\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);\n  }\n});\nclass ReplaceSupers {\n  constructor(opts) {\n    var _opts$constantSuper;\n    const path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;\n    this.opts = opts;\n  }\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) {\n      return cloneNode(this.opts.getSuperRef());\n    }\n  }\n  replace() {\n    const {\n      methodPath\n    } = this;\n    if (this.opts.refToPreserve) {\n      methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name\n      });\n    }\n    const handler = this.constantSuper ? looseHandlers : this.file.availableHelper(\"superPropSet\") ? specHandlers : specHandlers_old;\n    visitor.shouldSkip = path => {\n      if (path.parentPath === methodPath) {\n        if (path.parentKey === \"decorators\" || path.parentKey === \"key\") {\n          return true;\n        }\n      }\n    };\n    (0, _helperMemberExpressionToFunctions.default)(methodPath, visitor, Object.assign({\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      boundGet: handler.get\n    }, handler));\n  }\n}\nexports.default = ReplaceSupers;\n\n//# sourceMappingURL=index.js.map\n"]}